\subsection*{Introduction }

Java\+C\+V uses wrappers from the \href{https://github.com/bytedeco/javacpp-presets}{\tt Java\+C\+P\+P Presets} of commonly used libraries by researchers in the field of computer vision (\href{http://opencv.org/}{\tt Open\+C\+V}, \href{http://ffmpeg.org/}{\tt F\+Fmpeg}, \href{http://damien.douxchamps.net/ieee1394/libdc1394/}{\tt libdc1394}, \href{http://www.ptgrey.com/products/pgrflycapture/}{\tt P\+G\+R Fly\+Capture}, \href{http://openkinect.org/}{\tt Open\+Kinect}, \href{http://muonics.net/school/spring05/videoInput/}{\tt video\+Input}, \href{http://studierstube.icg.tugraz.at/handheld_ar/artoolkitplus.php}{\tt A\+R\+Tool\+Kit\+Plus}, and \href{http://cmp.felk.cvut.cz/~uricamic/flandmark/}{\tt flandmark}), and provides utility classes to make their functionality easier to use on the Java platform, including Android.

Java\+C\+V also comes with hardware accelerated full-\/screen image display ({\ttfamily Canvas\+Frame} and {\ttfamily G\+L\+Canvas\+Frame}), easy-\/to-\/use methods to execute code in parallel on multiple cores ({\ttfamily Parallel}), user-\/friendly geometric and color calibration of cameras and projectors ({\ttfamily Geometric\+Calibrator}, {\ttfamily Pro\+Cam\+Geometric\+Calibrator}, {\ttfamily Pro\+Cam\+Color\+Calibrator}), detection and matching of feature points ({\ttfamily Object\+Finder}), a set of classes that implement direct image alignment of projector-\/camera systems (mainly {\ttfamily G\+N\+Image\+Aligner}, {\ttfamily Projective\+Transformer}, {\ttfamily Projective\+Color\+Transformer}, {\ttfamily Pro\+Cam\+Transformer}, and {\ttfamily Reflectance\+Initializer}), a blob analysis package ({\ttfamily Blobs}), as well as miscellaneous functionality in the {\ttfamily Java\+C\+V} class. Some of these classes also have an Open\+C\+L and Open\+G\+L counterpart, their names ending with {\ttfamily C\+L} or starting with {\ttfamily G\+L}, i.\+e.\+: {\ttfamily Java\+C\+V\+C\+L}, {\ttfamily G\+L\+Canvas\+Frame}, etc.

To learn how to use the A\+P\+I, since documentation currently lacks, please refer to the \href{#sample-usage}{\tt Sample Usage} section below as well as the \href{https://github.com/bytedeco/javacv/tree/master/samples/}{\tt sample programs}, including two for Android ({\ttfamily Face\+Preview.\+java} and {\ttfamily Record\+Activity.\+java}), also found in the {\ttfamily samples} directory. You may also find it useful to refer to the source code of \href{https://github.com/bytedeco/procamcalib}{\tt Pro\+Cam\+Calib} and \href{https://github.com/bytedeco/procamtracker}{\tt Pro\+Cam\+Tracker} as well as \href{https://github.com/bytedeco/javacv-examples/}{\tt examples ported from Open\+C\+V2 Cookbook} and the associated \href{http://code.google.com/p/javacv/wiki/OpenCV2_Cookbook_Examples}{\tt wiki pages}.

Please keep me informed of any updates or fixes you make to the code so that I may integrate them into the next release. Thank you! And feel free to ask questions on \href{http://groups.google.com/group/javacv}{\tt the mailing list} if you encounter any problems with the software! I am sure it is far from perfect...

\subsection*{Downloads }

To install manually the J\+A\+R files, obtain the following archives and follow the instructions in the \href{#manual-installation}{\tt Manual Installation} section below.


\begin{DoxyItemize}
\item Java\+C\+V 0.\+10 binary archive \href{http://search.maven.org/remotecontent?filepath=org/bytedeco/javacv/0.10/javacv-0.10-bin.zip}{\tt javacv-\/0.\+10-\/bin.\+zip} (136 M\+B)
\item Java\+C\+V 0.\+10 source archive \href{http://search.maven.org/remotecontent?filepath=org/bytedeco/javacv/0.10/javacv-0.10-src.zip}{\tt javacv-\/0.\+10-\/src.\+zip} (381 K\+B)
\end{DoxyItemize}

The binary archive contains builds for Linux, Mac O\+S X, Windows, and Android. The J\+A\+R files for specific child modules or platforms can also be obtained individually from the \href{http://search.maven.org/#search|ga|1|bytedeco}{\tt Maven Central Repository}.

We can also have everything downloaded and installed automatically with\+:


\begin{DoxyItemize}
\item Maven (inside the {\ttfamily pom.\+xml} file) ```xml $<$dependency$>$ $<$group\+Id$>$org.\+bytedeco$<$/group\+Id$>$ $<$artifact\+Id$>$javacv$<$/artifact\+Id$>$ $<$version$>$0.\+10$<$/version$>$ $<$/dependency$>$ ```
\item Gradle (inside the {\ttfamily build.\+gradle} file) ```groovy dependencies \{ compile group\+: \textquotesingle{}org.\+bytedeco\textquotesingle{}, name\+: \textquotesingle{}javacv\textquotesingle{}, version\+: \textquotesingle{}0.\+10\textquotesingle{} \} ```
\item S\+B\+T (inside the {\ttfamily build.\+sbt} file) ```scala classpath\+Types += \char`\"{}maven-\/plugin\char`\"{} library\+Dependencies += \char`\"{}org.\+bytedeco\char`\"{} \% \char`\"{}javacv\char`\"{} \% \char`\"{}0.\+10\char`\"{} ```
\end{DoxyItemize}

Additionally, we need to either set the {\ttfamily platform.\+dependency} system property (via the {\ttfamily -\/\+D} command line option) to something like {\ttfamily android-\/arm}, or set the {\ttfamily platform.\+dependencies} one to {\ttfamily true} to get all the binaries for Linux, Mac O\+S X, and Windows. On build systems where this does not work, we need to add the platform-\/specific artifacts manually.

\subsection*{Required Software }

To use Java\+C\+V, you will first need to download and install the following software\+:


\begin{DoxyItemize}
\item An implementation of Java S\+E 6 or newer
\begin{DoxyItemize}
\item Open\+J\+D\+K \href{http://openjdk.java.net/install/}{\tt http\+://openjdk.\+java.\+net/install/} or
\item Sun J\+D\+K \href{http://www.oracle.com/technetwork/java/javase/downloads/}{\tt http\+://www.\+oracle.\+com/technetwork/java/javase/downloads/} or
\item I\+B\+M J\+D\+K \href{http://www.ibm.com/developerworks/java/jdk/}{\tt http\+://www.\+ibm.\+com/developerworks/java/jdk/} or
\item Java S\+E for Mac O\+S X \href{http://developer.apple.com/java/}{\tt http\+://developer.\+apple.\+com/java/} etc.
\end{DoxyItemize}
\end{DoxyItemize}

Further, although not always required, some functionality of Java\+C\+V also relies on\+:


\begin{DoxyItemize}
\item C\+L Eye Platform S\+D\+K (Windows only) \href{http://codelaboratories.com/downloads/}{\tt http\+://codelaboratories.\+com/downloads/}
\item Android S\+D\+K A\+P\+I 8 or newer \href{http://developer.android.com/sdk/}{\tt http\+://developer.\+android.\+com/sdk/}
\item J\+O\+C\+L and J\+O\+G\+L from Jog\+Amp \href{http://jogamp.org/}{\tt http\+://jogamp.\+org/}
\end{DoxyItemize}

Finally, please make sure everything has the same bitness\+: {\bfseries 32-\/bit and 64-\/bit modules do not mix under any circumstances}.

\subsection*{Manual Installation }

Simply put all the desired J\+A\+R files ({\ttfamily opencv$\ast$.jar}, {\ttfamily ffmpeg$\ast$.jar}, etc.), in addition to {\ttfamily javacpp.\+jar} and {\ttfamily javacv.\+jar}, somewhere in your C\+L\+A\+S\+S\+P\+A\+T\+H. Here are some more specific instructions for common cases\+:

Net\+Beans (Java S\+E 6 or newer)\+:


\begin{DoxyEnumerate}
\item In the Projects window, right-\/click the Libraries node of your project, and select \char`\"{}\+Add J\+A\+R/\+Folder...\char`\"{}.
\item Locate the J\+A\+R files, select them, and click O\+K.
\end{DoxyEnumerate}

Eclipse (Java S\+E 6 or newer)\+:


\begin{DoxyEnumerate}
\item Navigate to Project $>$ Properties $>$ Java Build Path $>$ Libraries and click \char`\"{}\+Add External J\+A\+Rs...\char`\"{}.
\item Locate the J\+A\+R files, select them, and click O\+K.
\end{DoxyEnumerate}

Intelli\+J I\+D\+E\+A (Android 2.\+2 or newer)\+:


\begin{DoxyEnumerate}
\item Follow the instructions on this page\+: \href{http://developer.android.com/training/basics/firstapp/}{\tt http\+://developer.\+android.\+com/training/basics/firstapp/}
\item Copy all the J\+A\+R files into the {\ttfamily app/libs} subdirectory.
\item Navigate to File $>$ Project Structure $>$ app $>$ Dependencies, click {\ttfamily +}, and select \char`\"{}2 File dependency\char`\"{}.
\item Select all the J\+A\+R files from the {\ttfamily libs} subdirectory.
\end{DoxyEnumerate}

After that, the wrapper classes for Open\+C\+V and F\+Fmpeg, for example, can automatically access all of their C/\+C++ A\+P\+Is\+:


\begin{DoxyItemize}
\item \href{http://docs.opencv.org/}{\tt Open\+C\+V documentation}
\item \href{http://ffmpeg.org/doxygen/}{\tt F\+Fmpeg documentation}
\end{DoxyItemize}

\subsection*{Sample Usage }

The class definitions are basically ports to Java of the original header files in C/\+C++, and I deliberately decided to keep as much of the original syntax as possible. For example, here is a method that tries to load an image file, smooth it, and save it back to disk\+:

```java import static org.\+bytedeco.\+javacpp.\+opencv\+\_\+core.$\ast$; import static org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.$\ast$; import static org.\+bytedeco.\+javacpp.\+opencv\+\_\+highgui.$\ast$;

public class Smoother \{ public static void smooth(\+String filename) \{ Ipl\+Image image = cv\+Load\+Image(filename); if (image != null) \{ cv\+Smooth(image, image); cv\+Save\+Image(filename, image); cv\+Release\+Image(image); \} \} \} ```

Java\+C\+V also comes with helper classes and methods on top of Open\+C\+V and F\+Fmpeg to facilitate their integration to the Java platform. Here is a small demo program demonstrating the most frequently useful parts\+:

```java import java.\+io.\+File; import java.\+net.\+U\+R\+L; import org.\+bytedeco.\+javacv.$\ast$; import org.\+bytedeco.\+javacpp.$\ast$; import org.\+bytedeco.\+javacpp.\+indexer.$\ast$; import static org.\+bytedeco.\+javacpp.\+opencv\+\_\+core.$\ast$; import static org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.$\ast$; import static org.\+bytedeco.\+javacpp.\+opencv\+\_\+calib3d.$\ast$; import static org.\+bytedeco.\+javacpp.\+opencv\+\_\+objdetect.$\ast$;

public class Demo \{ public static void main(\+String\mbox{[}$\,$\mbox{]} args) throws Exception \{ String classifier\+Name = null; if (args.\+length $>$ 0) \{ classifier\+Name = args\mbox{[}0\mbox{]}; \} else \{ U\+R\+L url = new U\+R\+L(\char`\"{}https\+://raw.\+github.\+com/\+Itseez/opencv/2.\+4/data/haarcascades/haarcascade\+\_\+frontalface\+\_\+alt.\+xml\char`\"{}); File file = Loader.\+extract\+Resource(url, null, \char`\"{}classifier\char`\"{}, \char`\"{}.\+xml\char`\"{}); file.\+delete\+On\+Exit(); classifier\+Name = file.\+get\+Absolute\+Path(); \}

// Preload the opencv\+\_\+objdetect module to work around a known bug. Loader.\+load(opencv\+\_\+objdetect.\+class);

// We can \char`\"{}cast\char`\"{} Pointer objects by instantiating a new object of the desired class. Cv\+Haar\+Classifier\+Cascade classifier = new Cv\+Haar\+Classifier\+Cascade(cv\+Load(classifier\+Name)); if (classifier.\+is\+Null()) \{ System.\+err.\+println(\char`\"{}\+Error loading classifier file \textbackslash{}\char`\"{}\char`\"{} + classifier\+Name + \char`\"{}"."); System.\+exit(1); \}

// The available Frame\+Grabber classes include Open\+C\+V\+Frame\+Grabber (opencv\+\_\+highgui), // D\+C1394\+Frame\+Grabber, Fly\+Capture\+Frame\+Grabber, Open\+Kinect\+Frame\+Grabber, // P\+S3\+Eye\+Frame\+Grabber, Video\+Input\+Frame\+Grabber, and F\+Fmpeg\+Frame\+Grabber. Frame\+Grabber grabber = Frame\+Grabber.\+create\+Default(0); grabber.\+start();

// F\+A\+Q about Ipl\+Image\+: // -\/ For custom raw processing of data, create\+Buffer() returns an N\+I\+O direct // buffer wrapped around the memory pointed by image\+Data, and under Android we can // also use that Buffer with Bitmap.\+copy\+Pixels\+From\+Buffer() and copy\+Pixels\+To\+Buffer(). // -\/ To get a Buffered\+Image from an Ipl\+Image, we may call get\+Buffered\+Image(). // -\/ The create\+From() factory method can construct an Ipl\+Image from a Buffered\+Image. // -\/ There are also a few copy$\ast$() methods for Buffered\+Image$<$-\/$>$Ipl\+Image data transfers. Ipl\+Image grabbed\+Image = grabber.\+grab(); int width = grabbed\+Image.\+width(); int height = grabbed\+Image.\+height(); Ipl\+Image gray\+Image = Ipl\+Image.\+create(width, height, I\+P\+L\+\_\+\+D\+E\+P\+T\+H\+\_\+8\+U, 1); Ipl\+Image rotated\+Image = grabbed\+Image.\+clone();

// Objects allocated with a create$\ast$() or clone() factory method are automatically released // by the garbage collector, but may still be explicitly released by calling release(). // You shall N\+O\+T call cv\+Release\+Image(), cv\+Release\+Mem\+Storage(), etc. on objects allocated this way. Cv\+Mem\+Storage storage = Cv\+Mem\+Storage.\+create();

// The Open\+C\+V\+Frame\+Recorder class simply uses the Cv\+Video\+Writer of opencv\+\_\+highgui, // but F\+Fmpeg\+Frame\+Recorder also exists as a more versatile alternative. Frame\+Recorder recorder = Frame\+Recorder.\+create\+Default(\char`\"{}output.\+avi\char`\"{}, width, height); recorder.\+start();

// Canvas\+Frame is a J\+Frame containing a Canvas component, which is hardware accelerated. // It can also switch into full-\/screen mode when called with a screen\+Number. // We should also specify the relative monitor/camera response for proper gamma correction. Canvas\+Frame frame = new Canvas\+Frame(\char`\"{}\+Some Title\char`\"{}, Canvas\+Frame.\+get\+Default\+Gamma()/grabber.get\+Gamma());

// Let\textquotesingle{}s create some random 3\+D rotation... Cv\+Mat random\+R = Cv\+Mat.\+create(3, 3), random\+Axis = Cv\+Mat.\+create(3, 1); // We can easily and efficiently access the elements of matrices and images // through an Indexer object with the set of get() and put() methods. Double\+Indexer Ridx = random\+R.\+create\+Indexer(), axis\+Idx = random\+Axis.\+create\+Indexer(); axis\+Idx.\+put(0, (Math.\+random()-\/0.\+5)/4, (Math.\+random()-\/0.\+5)/4, (Math.\+random()-\/0.\+5)/4); cv\+Rodrigues2(random\+Axis, random\+R, null); double f = (width + height)/2.0; Ridx.\+put(0, 2, Ridx.\+get(0, 2)$\ast$f); Ridx.\+put(1, 2, Ridx.\+get(1, 2)$\ast$f); Ridx.\+put(2, 0, Ridx.\+get(2, 0)/f); Ridx.\+put(2, 1, Ridx.\+get(2, 1)/f); System.\+out.\+println(\+Ridx);

// We can allocate native arrays using constructors taking an integer as argument. Cv\+Point hat\+Points = new Cv\+Point(3);

while (frame.\+is\+Visible() \&\& (grabbed\+Image = grabber.\+grab()) != null) \{ cv\+Clear\+Mem\+Storage(storage);

// Let\textquotesingle{}s try to detect some faces! but we need a grayscale image... cv\+Cvt\+Color(grabbed\+Image, gray\+Image, C\+V\+\_\+\+B\+G\+R2\+G\+R\+A\+Y); Cv\+Seq faces = cv\+Haar\+Detect\+Objects(gray\+Image, classifier, storage, 1.\+1, 3, C\+V\+\_\+\+H\+A\+A\+R\+\_\+\+D\+O\+\_\+\+C\+A\+N\+N\+Y\+\_\+\+P\+R\+U\+N\+I\+N\+G); int total = faces.\+total(); for (int i = 0; i $<$ total; i++) \{ Cv\+Rect r = new Cv\+Rect(cv\+Get\+Seq\+Elem(faces, i)); int x = r.\+x(), y = r.\+y(), w = r.\+width(), h = r.\+height(); cv\+Rectangle(grabbed\+Image, cv\+Point(x, y), cv\+Point(x+w, y+h), Cv\+Scalar.\+R\+E\+D, 1, C\+V\+\_\+\+A\+A, 0);

// To access or pass as argument the elements of a native array, call position() before. hat\+Points.\+position(0).x(x-\/w/10) .y(y-\/h/10); hat\+Points.\+position(1).x(x+w$\ast$11/10).y(y-\/h/10); hat\+Points.\+position(2).x(x+w/2) .y(y-\/h/2); cv\+Fill\+Convex\+Poly(grabbed\+Image, hat\+Points.\+position(0), 3, Cv\+Scalar.\+G\+R\+E\+E\+N, C\+V\+\_\+\+A\+A, 0); \}

// Let\textquotesingle{}s find some contours! but first some thresholding... cv\+Threshold(gray\+Image, gray\+Image, 64, 255, C\+V\+\_\+\+T\+H\+R\+E\+S\+H\+\_\+\+B\+I\+N\+A\+R\+Y);

// To check if an output argument is null we may call either is\+Null() or equals(null). Cv\+Seq contour = new Cv\+Seq(null); cv\+Find\+Contours(gray\+Image, storage, contour, Loader.\+sizeof(Cv\+Contour.\+class), C\+V\+\_\+\+R\+E\+T\+R\+\_\+\+L\+I\+S\+T, C\+V\+\_\+\+C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+S\+I\+M\+P\+L\+E); while (contour != null \&\& !contour.is\+Null()) \{ if (contour.\+elem\+\_\+size() $>$ 0) \{ Cv\+Seq points = cv\+Approx\+Poly(contour, Loader.\+sizeof(Cv\+Contour.\+class), storage, C\+V\+\_\+\+P\+O\+L\+Y\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+D\+P, cv\+Contour\+Perimeter(contour)$\ast$0.02, 0); cv\+Draw\+Contours(grabbed\+Image, points, Cv\+Scalar.\+B\+L\+U\+E, Cv\+Scalar.\+B\+L\+U\+E, -\/1, 1, C\+V\+\_\+\+A\+A); \} contour = contour.\+h\+\_\+next(); \}

cv\+Warp\+Perspective(grabbed\+Image, rotated\+Image, random\+R);

frame.\+show\+Image(rotated\+Image); recorder.\+record(rotated\+Image); \} frame.\+dispose(); recorder.\+stop(); grabber.\+stop(); \} \} ```

Furthermore, after creating a {\ttfamily pom.\+xml} file with the following content\+: ```xml $<$project$>$ $<$model\+Version$>$4.\+0.\+0$<$/model\+Version$>$ $<$group\+Id$>$org.\+bytedeco.\+javacv$<$/group\+Id$>$ $<$artifact\+Id$>$demo$<$/artifact\+Id$>$ $<$version$>$0.\+10$<$/version$>$ $<$dependencies$>$ $<$dependency$>$ $<$group\+Id$>$org.\+bytedeco$<$/group\+Id$>$ $<$artifact\+Id$>$javacv$<$/artifact\+Id$>$ $<$version$>$0.\+10$<$/version$>$ $<$/dependency$>$ $<$/dependencies$>$ $<$/project$>$ ```

And by placing the source code above in {\ttfamily src/main/java/\+Demo.\+java}, we can use the following command to have everything first installed automatically and then executed by Maven\+: ```bash \$ mvn package exec\+:java -\/\+Dplatform.\+dependencies -\/\+Dexec.\+main\+Class=Demo ```

\subsection*{Build Instructions }

If the binary files available above are not enough for your needs, you might need to rebuild them from the source code. To this end, the project files were created for\+:


\begin{DoxyItemize}
\item Maven 2 or 3 \href{http://maven.apache.org/download.html}{\tt http\+://maven.\+apache.\+org/download.\+html}
\item Java\+C\+P\+P 0.\+10 \href{https://github.com/bytedeco/javacpp}{\tt https\+://github.\+com/bytedeco/javacpp}
\item Java\+C\+P\+P Presets 0.\+10 \href{https://github.com/bytedeco/javacpp-presets}{\tt https\+://github.\+com/bytedeco/javacpp-\/presets}
\end{DoxyItemize}

Once installed, simply call the usual {\ttfamily mvn install} command for Java\+C\+P\+P, its Presets, and Java\+C\+V. By default, no other dependencies than a C++ compiler for Java\+C\+P\+P are required. Please refer to the comments inside the {\ttfamily pom.\+xml} files for further details.



 Project lead\+: Samuel Audet \href{mailto:samuel.audet at gmail.com}{\tt samuel.\+audet `at` gmail.\+com} Developer site\+: \href{https://github.com/bytedeco/javacv}{\tt https\+://github.\+com/bytedeco/javacv} Discussion group\+: \href{http://groups.google.com/group/javacv}{\tt http\+://groups.\+google.\+com/group/javacv}

Licensed under the G\+N\+U General Public License version 2 (G\+P\+Lv2) {\bfseries with Classpath exception}. Please refer to L\+I\+C\+E\+N\+S\+E.\+txt or \href{http://www.gnu.org/software/classpath/license.html}{\tt http\+://www.\+gnu.\+org/software/classpath/license.\+html} for details. 